## UDP套接字编程

### 获取数据报的目的地址和接口

绑定通配地址的UDP套接字不能确定其接受到的数据报的目的地址，也不能确定是数据报来源于哪一个接口。

解决办法

使用套接字选项IP_RECVDSTADDR获取IP地址，IP_RECVIF获取接口地址。在调用recvmsg函数获取数据报前，设置上述两个套接字选项，对应的信息将在附加数据段中返回。

### 收到超长数据报

对于支持msghdr及其msg_flags标志的实现，当接收到的数据报大于缓冲区大小时，msg_flags返回MSG_TRUNC标志；有些实现则直接丢掉；有些实现需在后续读操作中读出后续部分。

解决办法

设置缓冲区大小大于期望的最大大小一个字节，如果返回的数据占满了缓冲区，则认为超长了。

### 使用UDP的情况

使用UDP不必建立连接，在通信时减少时间消耗。对于要求可靠性的通信，要实现丢失重传，重复分组检测，乱序到达分组的排序，确认。一般通过序列号实现。

另外进行广播，多播时只能使用UDP，不能使用TCP。因为TCP不支持。

## 程序例子

### 1、增加UDP的可靠性 

程序的一些说明

1、程序大部分参照unix网络编程的思路编写.

2、程序为UDP增加了超时重传和丢失重传机制，是增加UDP可靠性的一种方式。

3、程序属于停等模式，发送数据必须等待接收后才能发送下一个数据，使用流水线机制需要使用滑动窗口协议。

#### 程序中出现的错误

1、第197行返回值。错误的认为recvmsg函数会填充iov_len，实际要获得最后一个缓冲区的大小应该使用recvmsg的返回值-前面的缓冲区大小。

现象：输出多了一些换行


2、recvmsg函数返回0。原因：忘记初始化recvHdr.msg_iov，导致没有为接受函数分配缓冲区。所以返回0；

### 2、为套接字绑定端口

通过绑定接口的方式，能够使得不同目的地址的数据报单独处理。采用的方式是先使用unix高级编程书中实现的接口信息获取函数get_ifi_info获取接口信息。对于函数返回的每一项，创建一个套接字与其IP地址绑定（由于端口相同，所以需要使用SO_REUSEADDR选项）。最后使用通配IP地址绑定一个套接字，以处理前面没有绑定的目的IP地址的数据报。

上述每绑定一个数据报，就创建一个进程，单独处理以绑定地址为目的地址的数据报。

用于get_ifi_info函数返回的每一项都包含一个广播地址，而在将同一个广播地址绑定多次会返回EADDRINUSE错误，所以在bind返回上述错误时，我们放弃绑定，以避免重复绑定。

注：1、一个接口可以有多个别名IP地址，get_ifi_info函数为每个别名地址单独返回一项，同时接口的广播地址会被复制到每一个别名地址中。

2、最后能到达绑定通配地址套接字的只有受限广播地址255.255.255.255

### 3、并发UDP服务器

对于只有一次交互的C/S可以直接fork一个子进程处理

对于存在多次交互的。在主进程接收到第一个请求后，创建一个套接字，并绑定一个新的端口，通过这个新的套接字发送应答。客户端在接收到第一个应答后，可知为其提供服务的套接字的端口号，以后向这个端口号发送请求即可。

注：对于使用超级服务器xinetd的来说，用于存在wait标志，要特殊处理。
