## 笔记

### IPv4和IPv6的互操作

其地址变换操作应该在TCP和IP层之间的接口函数，如connect，accept进行处理。

#### IPv4客户端访问IPv6服务器

IPv4客户端得到A类型的DNS的资源条目，即得到服务器的IPv4地址。调用connect函数，当connect请求到达服务器时，服务器设置一个标志，指示本连接使用IPv4映射的IPv6地址，并由accept返回映射的IPv6地址。

当服务器向客户端发送信息时，服务器将映射的IPv6地址转换为IPv4地址。

注：

1.数据传输使用的IPv4

2.对UDP也是同样的道理

3.服务器应该是双栈的IPv6服务器

4.这种分析的假设是服务器同时用IPv4地址和IPv6地址。

#### IPv6客户端访问IPv4服务器

此时DNS中应该有服务器从IPv4到IPv6的映射条目。同时IPv4的地址获取函数getaddrinfo应该设置AI_V4MAPPED。内核检测到使用IPv4映射的IPv6地址时，会发送一个IPv4的分节，从而实现通信。

注：

1.数据传输使用的仍然是IPv4

2.对UDP同样适用

3.要求客户机是双栈的，对于服务器不要求。

#### 补充

上述两种通信方式，客户端和服务器都不知道与其通信的对端采用哪一种协议，这种问题可以使用netinet.h中的宏进行判定。

例如：IPv6客户可以调用IN6_IS_ADDR_V4MAPPED(const struct in6_addr *aptr);判定解析器返回的IPv6地址是不是映射得到的。


### 守护进程

守护进程是后台运行且不与任何控制终端关联的进程。1、由系统初始化脚本启动。2、由控制终端启动，但要脱离与控制终端的关联。这里介绍两种守护进程，rsyslogd和xinetd，分别用于日志管理和服务器管理。

许多网络服务器作为守护进程运行。并将必要输出的信息传递给syslogd进行记录。

#### rsyslogd

rsyslogd是syslogd的升级版。配置文件为/etc/rsyslog.conf，可以直接指定各种日志消息应该如何处理,也可以通过另外包含配置文件的方式指定。语法可以参见鸟哥私房菜的第十九章.

可以通过unix域数据报套接字,udp套接字,以及/dev/klog端口的方式,从自己的守护进程向syslogd发送日志消息.但通常使用syslog函数.无论采取哪一种方式，效果都是一样的，日志消息最终存储在哪一个文件中取决于/etc/rsyslog文件中的配置。


`void syslog(int priority,const char *message,argument);`

头文件：syslog.h

priority:是level和facility二者的组合，未指定level时，level默认为LOG_NOTICE.

message:类似于printf的格式化字符串，但是增加了%m功能。%m将被替换成当前errno值对应的出错信息。

argument:上面格式化字符串的变量。

例子：

syslog(LOG_INFO | LOG_LOCAL2,"This is a message of %s\n",argv[0]);表示发送信息的进程类型为本地使用，级别为通告信息。最终输出结果为This is a message of 程序名。


`void openlog(const char *ident,int options,int facility);`

该函数在syslog前运行，帮助syslog打开unix域数据报套接字。如果不调用，sysylog将在第一次被调用时，自己打开。

ident:放在每个日志消息之前的字符串，一般为程序名

options：指定打开unix域数据报套接字的一些性质（参见头文件）

facility:如果在syslog中没有指定的facility，其作为默认值。

`void closelog(void);`  关闭unix域数据报套接字。

### 将服务器进程转换为守护进程

需要脱离shell，同时做一些其他的处理，但是我们对这个操作并不急需，同时有一些并不理解的原理，所以等到需要的时候再做补充。

### xinetd守护进程

使用超级服务器可以通过单个进程为多个服务等待外来的客户请求，可以减少系统的进程数。
xinetd根据自己配置文件/etc/xinetd.conf决定处理哪些服务，以及当服务请求到达时怎么处理.

通过xinetd管理服务器时，xinetd函数会运行初始的绑定，listen，以及select监测listen端口，当有请求到来时，会调用accept并创建一个子进程，在子进程中将stdin，stdout，stderr都绑定到accept返回的套接字上面。然后切换用户，并调用exec。因此我们编写的程序中，stdin，stdout，stderr就相当于套接字，我们对它们进行输入输出即可。

nowait:表示应用进程不必等待某个子进程终止，就可以接受另一个连接，如tcp；

wait：表示应用进程必须等待子进程终止才能为下一个请求服务，即在子进程结束之前要关闭xinetd的select中，对于该套接字的监测。如udp需要设为wait。

注：xinetd不适用于服务密集型服务器，因为对于每个服务既要有fork的开销，又要有exec的开销。

### 标准I/O函数库

由于标准I/O库对于除了标准错误外的其他I/O流默认使用全缓冲，所以一般要避免在套接字上面使用标准I/O库函数。

完全缓冲：在缓冲区满、调用fflush函数或者调用进程调用exit函数终止时才输出。

行缓冲；不缓冲；

### T/TCP 事务目的TCP

是一种通过结合SYN，FIN，数据分节以减少RTT的TCP协议的修改版本。

客户通过调用sendto结合套接字选项和函数选项，而避免调用connect，shutdown函数，从而节省时间。

事务：含义是客户的请求和服务器的应答。如DNS，，HTTP

### tcpdump抓包程序

可以使用特定的表达式来分析指定主机和指定端口，以及他们之间的数据包。

tcpdump -D列出可用于抓包的接口

tcpdump -c num -i interface -nn -XX -vvv //从interface抓取num数量的包，nn显示端口为数值，XX头部数据以16进制和ASCII两种方式输出，更详细。vvv表示详细输出。

表达式

用来对数据包进行过滤，可以通过指定数据包的来源和目的，数据包的方向，数据包的协议，筛选出自己想要的数据包。

host/net/port/portrange 用来指定数据包的来源和目的。分别是指定主机 host foo，网段net 128.3，端口port 22，端口范围portrange 600-619

src/dst 中间可以用or 或者 and连接。一般和上面的一起使用，如src or dst port 22

proto 指定协议时不写proto关键字，直接使用如tcp。

表达式由表达式单元组成，每个单元的格式位 proto dir type ID，不同单元之间可以使用and、&&、or、||、not、!连接。

#### 举例

tcpdump -w tcpd tcp and port 7 //将来自会去往端口7的tcp数据包获取。


### 广播

1、只能在数据报套接字间，进行广播。不能在TCP这样基于连接的传输协议上广播。

2、只能在支持广播的网络上广播，不能在点对点的链路上进行广播。

3、在广播前必须设置SO_BROADCAST套接字选项。如果目的地址是广播地址，但相应的套接字选项没有设置，则返回EACCES错误。

4、所有的应答数据报都是单播的。

5、通常广播数据报不允许分片，如果目的地址是广播地址的数据报大小超过外出接口的MTU，则发送它的系统调用将返回EMSGSIZE。一些操作系统实现允许分片。

#### 优缺点

优点；可以用于DNS，NTP（Net Time Protocol）；

缺点：子网中的所有主机都要接收，即使不参与广播应用的主机也要接收，对于UDP数据报要一直向上传递到传输层。对于高速率的应用会带来较大的负担。

### 竞争

竞争是指多个进程访问共享的数据，而访问结果取决于进程的执行顺序。对于信号的竞争要考虑信号在不同时间发生，可能导致运行结果不同的情况，要特别注意信号可能在任意一条语句的前面或后面到来。比如信号处理函数设置了一个全局变量，主控函数在检测这个全局变量的时候，如果发生信号的递交，就可能出现错误。

1、处理信号竞争问题可以使用pselect函数。方法参见/socket/functionSys.md中pselect函数的说明。

2、使用管道，在信号处理函数中将标志位写入管道，使用select监测管道。这样既不会阻塞在管道中，也不会阻塞在recvfrom函数中。

在处理竞争问题时，一定要小心谨慎，尽量使用成熟的解决方案。对于主程序中需要访问在信号处理函数中改动的数据之情况，会发生竞争状态。

### 超时

对读操作设置超时的常见方法是：使用alarm结合SIGALRM的信号处理函数。

### 多播

单播是一种一对一的通信，广播是主机对子网中所有主机通信，多播是主机对加入到多播组中的主机进行通信。

#### 多播地址

对于IPv4，D类地址(224.0.0.0~239.255.255.255)是多播地址。由于发送的信息要经过链路层，所以需要将IPv4转换为数据链路层的地址，多播的链路层地址也要区分于单播地址，其高24位为0x01 0x00 0x5e其中0x01中的1表示这24位为统一管理的组地址也就是由IEEE分配的。IPv4的多播的地址映射是将IPv4地址的低序23bit作为以太网地址的低序23位。从而进行转换。低序第24为恒为零。

对于IPv6，其高位16字节为0x33 0x33，其中第一个0x33中的3表示这是一个局部管理的组地址，不保证0x33 0x33开头的一定是多播组地址。IPv6的低32为IP地址作为以太网的低序32位。

#### 传输过程

发送方，指定多播组地址和一个端口号（和接收方的端口号相同），按照单播的发送流程发送信息。发送方不必加入多播组。

接收方，创建套接字，绑定一个端口，然后使用setsockopt加入一个多播组。之后IPv4会保存这些信息，并告知链路层接收IP地址对应以太网地址。

广域网中的传输需要通过多播路由的转发，主机在加入到某个多播分组后，会通知其路由器，路由在收到相应的分组后就会转发到该局域网内。要使用广域网的多播需要多播组具有唯一的多播地址。

#### 过滤方式

不完备过滤：网卡对于以太网地址的接收.先使用hash技术将要接收的以太网地址映射到一个值，如果到来的以太网地址与之相同，则接收。并传递给数据链路层做检测。

网卡工作在物理层和数据链路层的MAC子层。

数据链路层包含两个子层：1、MAC子层（介质访问控制子层）2、LLC（逻辑链路控制）子层。

完备过滤：IP层对接收到的IP地址和所加入的多播组地址进行比较，相同才接收

#### 编写多播程序

发送方：指定多播地址和端口，调用发送函数发送多播帧即可。也可通过IP_MULTICAST_IF，IP_MULTICAST_TTL，IP_MULTICAST_LOOP(IPV4)或IP6_MULTICAST_IF，IP6_MULTICAST_HOPS，IP_MULTICAST_LOOP(IPV4)分别指定输出端口，TTL，以及是否将发出的多播帧转发给自己。

接收方：

IP_ADD_MEMBERSHIP,IPV6_JOIN_CROUP,MCAST_JOIN_CROUP加入不限源的多播组。

IP_DROP_MEMBERSHIP,IPV6_LEAVE_CROUP,MCAST_LEAVE_CROUP退出不限源的多播组。

IP_BLOCK_SOURCE,MCAST_BLOCK_SOURCE在本套接字阻塞来自某个源的多播分组。UNBLOCK打开先前被阻塞的源。

IP_ADD_SOURCE_MEMBERSHIP,MCAST_JOIN_SOURCE_CROUP加入特定于源的多播组。

IP_DROP_SOURCE_MEMBERSHIP,MCAST_LEAVE_SOURCE_CROUP退出特定于源的多播组。

#### 注意

1、使用多播时，应该将套接字加入到多播组，并绑定端口。同时也应该为套接字绑定多播组地址。

2、一些老的主机不允许绑定多播地址到套接字，可以忽略bind多播地址的错误，并使用只绑定端口的方式重新绑定。

#### 多播的应用

比如在群视频的时候，发起视频的用户要呼叫多个用户进行应答，这是就需要使用多播。

#### 对比广播

1、允许分片


### 带外数据(out-of-band,OOB)

发送带外数据时，即使缓冲区内存在数据也会优先发送带外数据。但在TCP并没有严格实现带外数据，而是使用一种紧急模式，只能在产生带外数据时通知对端，而不能保证优先发送带外数据。

#### TCP的“带外数据”

对于TCP数据报，发送端存在带外数据时,会通过设置TCP头中的U标志位，标识发送的数据报。标识了U标志位的TCP数据报，会使对端产生信号或是导致select返回,从而通知对方.即使TCP因为流量控制不能发送数据，也不会影响到这种通知的传输。而标记了U的数据报中并不一定传输了带外数据.

##### 带外数据的通知

1、产生这种通知的好处是,能够告知对端进入一种特殊处理的模式.

2、对于使用信号通知进程的方式，涉及到使用fcntl或ioctl设置套接字属主的操作。

使用select时需要注意：由于select会在进程读数据越过带外数据（带外数据在接收队列的位置）前，一直产生通知，而带外数据在一次读出后，再读会报错。所以需要进行控制。如果迫切需要先读出带外数据，则需要设置标志位，以让带外数据先与普通数据读出，否则可以调换标志检查顺序。

##### 带外数据的值

3、对于发送端，TCP一次只能传输一个字节的带外数据.如果传输多个只有最后一个有效，其余被当做普通数据发送。

对于接收端涉及到是否将带外数据单独存储的SO_OOBINLINE套接字选项.（如果设置SO_OOBINLINE选项，前面的会被认为是普通数据，如果没有设置前面的将被覆盖）

4、带外数据的发送和以及未设置SO_OOBINLINE选项接收，通过在recv这种函数中指定MSG_OOB选项，设置了SO_OOBINLINE的利用读函数会在带外标记处停止来接收。

##### 带外数据的位置

5、带外标记。指示带外数据的位置，对于设置了SO_OOBINLINE的，读操作会在带外标记处停止（并不读入带外数据），即使后面仍有数据。使用sockatmask可以检测是否因为带外数据停止。


### 信号驱动式I/O

在套接字发生某事时，使用SIGIO通知进程。优点之一就是实时性比较好。

一般仅用于少量的UDP程序中，TCP程序几乎无法使用。

### IP层及数据链路层

初始在传输层编写程序之外，操作系统还提供直接访问IP层和数据链路层的方式。

在进行网络检测的程序中，往往需要访问IP层和数据链路层的信息，比如ping，traceroute需要访问ICMP报文，而tcpdump抓包程序需要访问数据链路层的信息。

这种操作一般都比较复杂，需要熟悉IP数据报的结构以及一些底层的工作原理。

在unix网络编程中有ping，traceroute以及tcpdump简单实现的例子，可以参照编写程序。

### 服务器结构设计

1、迭代

每次处理一个连接，在处理完后处理下一个。问题是后面的链接等待时间过长。

2、并发-进程

为每一个连接创建一个进程。缺点是每次创建进程要进行系统调用，耗费时间。

3、并发-预分配进程

1、预先分配若干个进程，将accept放到每一个进程中。这样每次到来一个连接时，所有阻塞在accept中的预分配进程都会返回，但是只有第一个会建立连接，其他的检测到可连接数为零，所以继续阻塞。这种现象叫惊群。

2、如果使用select还存在select冲突的问题。由于套接字中只存储一个在自己就绪是应该唤醒进程的ID，如果上面每一个进程都使用select监测listen套接字，那么listen套接字并不知道自己应该唤醒那个。所以它会唤醒所有阻塞在select中的进程，即使其中没有listen套接字。这样就会造成冲突    因此，这种情况下应该直接阻塞在accept中，而不应该阻塞在select里。

3、将accept直接放在进程的做法只适用于源自于Berkeley的实现，因为Berkeley的实现是由内核实现的，且可认为是原子操作。所以对于其他系统需要上锁。

4、并发-预分配进程-accept使用文件上锁保护

由于有些程序，要求不能同时访问同一个文件，操作系统一般都支持对文件上锁，在一个进程访问完该文件后，解锁，供其他进程访问。使用非函数是fcntl。

利用记录锁的阻塞模式，可以控制accept在同一时间只有一个进程访问。而这里记录锁锁住的文件并不是主题，所以使用mkstemp函数对一个路径名随机生成一个文件即可。

这种方法解决了惊群问题，某些系统accept不支持多进程操作的问题。

5、并发-预分配进程-accept使用线程上锁保护

使用线程的互斥锁进行保护，但是互斥量要声明为共享变量（使用mmap），并告知系统改互斥量在进程之间使用，即需要设置互斥量的参数。

6、并发-预分配进程-accept位于主函数，传递描述符

在创建进程时，同时创建父进程和子进程之间的通信通道（使用socketpair），在接受一个连接后，将对应的套接字描述符传递给，子进程。

7、并发每个客户一个线程

这种是比较基础的方式，时间耗费稍多，但是比每个客户一个进程要好很多。

8、并发-预分配线程-accept由线程调用，使用互斥锁保护

速度快于每个客户一个线程，对于Berkeley实现，如果不用互斥锁也行，但是也会出现惊群。

9、并发-预分配线程-accept由主线程调用

向线程传递描述符不需要使用管道等方式，因为线程之间共享内存空间。通过使用一个存放已连接描述符的数组，主线程对其更新，并使用条件变量通知线程这一更新，实现通知线程描述符的目的。这里显然也要使用互斥锁。

